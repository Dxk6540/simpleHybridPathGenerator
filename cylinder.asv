% date: 20230225
% test for alternative hybrid manufactuing a cylinder
% author: Xiaoke DENG


% file param:
filename = './supportTestV2.txt';


% process param
% pwr = 300; % 1.2KW / 4kw *1000;
% lenPos = 900;
% flowL = 300; % 6 L/min / 20L/min * 1000;
% speedL = 200;% 2 r/min / 10r/min * 1000;
% flowR = 300;% 6 L/min / 20L/min * 1000;
% speedR = 200;% 2 r/min / 10r/min * 1000;
% feedrate = 760; % mm/min

% support process param
pwr = 100; % 1.2KW / 4kw *1000;
lenPos = 900;
flowL = 200; % 6 L/min / 20L/min * 1000;
speedL = 100;% 2 r/min / 10r/min * 1000;
flowR = 200;% 6 L/min / 20L/min * 1000;
speedR = 100;% 2 r/min / 10r/min * 1000;
feedrate = 760; % mm/min

%  geometry param
startCenter = [20,-60];
% inclinationAgl = 0; % degree
lyrNum = 40;
lyrHeight = 0.5;
radius = 2;
tol = 0.3;

%%
%%%%%%%%%%%%%% printing path

% planar circle path
lyrPtNum = floor(2 * radius * pi / tol)+1;
aglStep = 2 * pi / lyrPtNum;
pathSeq = [];
pwrSeq = [];
for lyrIdx = 1:lyrNum
%     centerXOffset = ((lyrIdx - 1) * lyrHeight) * tan(inclinationAgl/180 * pi); 
    for j = 1 : lyrPtNum
%         x = cos(aglStep * j) * radius + startCenter(1) + centerXOffset;
        x = cos(aglStep * j) * radius + startCenter(1);
        y = sin(aglStep * j) * radius + startCenter(2);
        z = (lyrIdx - 1) * lyrHeight;
        pathSeq = [pathSeq; x,y,z];
        pwrSeq = [pwrSeq; pwr];
    end
    pwrSeq(end) = 0;
end

% generate the sequence for pwr / lenPos
lenPosSeq = ones(length(pathSeq),1) * lenPos;
% pwrSeq = ones(length(pathSeq),1) * pwr;







%%%%%%%%%%%%% following for path Gen %%%%%%%%%%%%%%%%%%%%%

pg = cPathGen(filename); % create the path generator object
pg.openFile();  % open the file

% the regular code for DED
pg.closeDoor(); % close door
pg.changeMode(1); % change to printing mode
pg.setLaser(300, 900, flowL, speedL, flowR, speedR); % set a init process param (in case of overshoot)

pg.saftyToPt([nan, nan, 200], [startCenter(1) - 5, startCenter(2), 0], 3000); % safety move the start pt
pg.pauseProgram();% pause and wait for start (the button)
pg.enableLaser(1, 10);


ret = pg.addPathPtsWithPwr(pathSeq, pwrSeq, lenPosSeq, feedrate);
ret 

pg.disableLaser(1);
pg.openDoor();
pg.endProgram();

pg.closeFile();

plot3(pathSeq(:,1),pathSeq(:,2),pathSeq(:,3))
axis equal


%%
%%%%%%%%%%%%%% machining path


wallOffset = 0.2;

% planar circle path
lyrPtNum = floor(2 * radius * pi / tol)+1;
aglStep = 2 * pi / lyrPtNum;
mPathSeq = [];
for lyrIdx = 1:lyrNum
%     centerXOffset = ((lyrIdx - 1) * lyrHeight) * tan(inclinationAgl/180 * pi); 
    for j = 1 : lyrPtNum
%         x = cos(aglStep * j) * radius + startCenter(1) + centerXOffset;
        x = cos(aglStep * j) * (radius + wallOffset) + startCenter(1);
        y = sin(aglStep * j) * (radius + wallOffset) + startCenter(2);
        z = (lyrIdx - 1) * lyrHeight;
        mPathSeq = [mPathSeq; x,y,z];
    end
end

%%%%%%%%%%%%% following for path Gen %%%%%%%%%%%%%%%%%%%%%

pg = cPathGen(filename); % create the path generator object
pg.openFile();  % open the file

% the regular code for DED
pg.closeDoor(); % close door
pg.changeMode(2); % change to printing mode
pg.setLaser(300, 900, flowL, speedL, flowR, speedR); % set a init process param (in case of overshoot)

pg.saftyToPt([nan, nan, 200], [startCenter(1) - 5, startCenter(2), 0], 3000); % safety move the start pt
pg.pauseProgram();% pause and wait for start (the button)
pg.enableLaser(1, 10);


ret = pg.addPathPtsWithPwr(pathSeq, pwrSeq, lenPosSeq, feedrate);
ret 

pg.disableLaser(1);
pg.openDoor();
pg.endProgram();

pg.closeFile();

plot3(pathSeq(:,1),pathSeq(:,2),pathSeq(:,3))
axis equal















int machiningTest(){
  double wpHeight = 10;
  double lyrHeight = 0.5;
  double tol = 0.1;
  double circleRad = 20;
  double centerX = 50;
  double centerY = 50;
  double feed = 600;

  path.createOutputFile("./machineTest.txt");
  path.closeDoor();
  path.changeMode(cGcodeGen::MACHINING);

  path.changeTool(1);
  path.addCmd("G01 Z200 F3000 ;;抬刀至安全平面");  
  path.pauseProgram();
  path.turnOnSpindle(10000);

  int lyrNum = (int)(wpHeight/lyrHeight); 
  double lyrPtNum = (int)(2 * 3.1415926535 * circleRad / tol + 1);
  double step = -2 * 3.1415926535 / lyrPtNum;

  for(int i = 0; i < lyrNum; i++){
    double curHeight = wpHeight - i * lyrHeight;
    for (int j = 0; j < lyrPtNum; j++){
    double x = centerX + circleRad * cos(step * j);
    double y = centerY + circleRad * sin(step * j);
    path.addPathPt(x, y, curHeight, feed);
    }
  }

  path.turnOffSpindle();
  path.addCmd("G01 Z200 F3000 ;;抬刀至安全平面");
  path.openDoor();
  path.endProgram();    
}


int main(){

  printingTest();
  machiningTest();
  return 0;
}

